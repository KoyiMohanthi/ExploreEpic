{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StreamProxy = exports.StreamType = void 0;\nconst googleError_1 = require(\"../googleError\");\nconst streamingRetryRequest_1 = require(\"../streamingRetryRequest\");\nconst status_1 = require(\"../status\");\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst duplexify = require('duplexify');\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst retryRequest = require('retry-request');\n/**\n * The type of gRPC streaming.\n * @enum {number}\n */\nvar StreamType;\n(function (StreamType) {\n  /** Client sends a single request, server streams responses. */\n  StreamType[StreamType[\"SERVER_STREAMING\"] = 1] = \"SERVER_STREAMING\";\n  /** Client streams requests, server returns a single response. */\n  StreamType[StreamType[\"CLIENT_STREAMING\"] = 2] = \"CLIENT_STREAMING\";\n  /** Both client and server stream objects. */\n  StreamType[StreamType[\"BIDI_STREAMING\"] = 3] = \"BIDI_STREAMING\";\n})(StreamType || (exports.StreamType = StreamType = {}));\nclass StreamProxy extends duplexify {\n  /**\n   * StreamProxy is a proxy to gRPC-streaming method.\n   *\n   * @private\n   * @constructor\n   * @param {StreamType} type - the type of gRPC stream.\n   * @param {ApiCallback} callback - the callback for further API call.\n   */\n  constructor(type, callback, rest, gaxServerStreamingRetries) {\n    super(undefined, undefined, {\n      objectMode: true,\n      readable: type !== StreamType.CLIENT_STREAMING,\n      writable: type !== StreamType.SERVER_STREAMING\n    });\n    this.retries = 0;\n    this.type = type;\n    this._callback = callback;\n    this._isCancelCalled = false;\n    this._responseHasSent = false;\n    this.rest = rest;\n    this.gaxServerStreamingRetries = gaxServerStreamingRetries;\n  }\n  cancel() {\n    if (this.stream) {\n      this.stream.cancel();\n    } else {\n      this._isCancelCalled = true;\n    }\n  }\n  retry(stream, retry) {\n    let retryArgument = this.argument;\n    if (typeof retry.getResumptionRequestFn === 'function') {\n      const resumptionRetryArgument = retry.getResumptionRequestFn(retryArgument);\n      if (resumptionRetryArgument !== undefined) {\n        retryArgument = retry.getResumptionRequestFn(retryArgument);\n      }\n    }\n    this.resetStreams(stream);\n    const newStream = this.apiCall(retryArgument, this._callback);\n    this.stream = newStream;\n    this.streamHandoffHelper(newStream, retry);\n    return newStream;\n  }\n  /**\n   * Helper function to handle total timeout + max retry check for server streaming retries\n   * @param {number} deadline - the current retry deadline\n   * @param {number} maxRetries - maximum total number of retries\n   * @param {number} totalTimeoutMillis - total timeout in milliseconds\n   */\n  throwIfMaxRetriesOrTotalTimeoutExceeded(deadline, maxRetries, totalTimeoutMillis) {\n    const now = new Date();\n    if (this.prevDeadline !== undefined && deadline && now.getTime() >= this.prevDeadline) {\n      const error = new googleError_1.GoogleError(`Total timeout of API exceeded ${totalTimeoutMillis} milliseconds before any response was received.`);\n      error.code = status_1.Status.DEADLINE_EXCEEDED;\n      this.emit('error', error);\n      this.destroy();\n      // Without throwing error you get unhandled error since we are returning a new stream\n      // There might be a better way to do this\n      throw error;\n    }\n    if (this.retries && this.retries >= maxRetries) {\n      const error = new googleError_1.GoogleError('Exceeded maximum number of retries before any ' + 'response was received');\n      error.code = status_1.Status.DEADLINE_EXCEEDED;\n      this.emit('error', error);\n      this.destroy();\n      throw error;\n    }\n  }\n  /**\n   * Error handler for server streaming retries\n   * @param {CancellableStream} stream - the stream being retried\n   * @param {RetryOptions} retry - Configures the exceptions upon which the\n   *   function should retry, and the parameters to the exponential backoff retry\n   *   algorithm.\n   * @param {Error} error - error to handle\n   */\n  streamHandoffErrorHandler(stream, retry, error) {\n    let retryStream = this.stream;\n    const delayMult = retry.backoffSettings.retryDelayMultiplier;\n    const maxDelay = retry.backoffSettings.maxRetryDelayMillis;\n    const timeoutMult = retry.backoffSettings.rpcTimeoutMultiplier;\n    const maxTimeout = retry.backoffSettings.maxRpcTimeoutMillis;\n    let delay = retry.backoffSettings.initialRetryDelayMillis;\n    let timeout = retry.backoffSettings.initialRpcTimeoutMillis;\n    let now = new Date();\n    let deadline = 0;\n    if (retry.backoffSettings.totalTimeoutMillis) {\n      deadline = now.getTime() + retry.backoffSettings.totalTimeoutMillis;\n    }\n    const maxRetries = retry.backoffSettings.maxRetries;\n    try {\n      this.throwIfMaxRetriesOrTotalTimeoutExceeded(deadline, maxRetries, retry.backoffSettings.totalTimeoutMillis);\n    } catch (error) {\n      return;\n    }\n    this.retries++;\n    const e = googleError_1.GoogleError.parseGRPCStatusDetails(error);\n    let shouldRetry = this.defaultShouldRetry(e, retry);\n    if (retry.shouldRetryFn) {\n      shouldRetry = retry.shouldRetryFn(e);\n    }\n    if (shouldRetry) {\n      const toSleep = Math.random() * delay;\n      setTimeout(() => {\n        now = new Date();\n        delay = Math.min(delay * delayMult, maxDelay);\n        const timeoutCal = timeout && timeoutMult ? timeout * timeoutMult : 0;\n        const rpcTimeout = maxTimeout ? maxTimeout : 0;\n        this.prevDeadline = deadline;\n        const newDeadline = deadline ? deadline - now.getTime() : 0;\n        timeout = Math.min(timeoutCal, rpcTimeout, newDeadline);\n      }, toSleep);\n    } else {\n      e.note = 'Exception occurred in retry method that was ' + 'not classified as transient';\n      // for some reason this error must be emitted here\n      // instead of the destroy, otherwise the error event\n      // is swallowed\n      this.emit('error', e);\n      this.destroy();\n      return;\n    }\n    retryStream = this.retry(stream, retry);\n    this.stream = retryStream;\n    return;\n  }\n  /**\n   * Used during server streaming retries to handle\n   * event forwarding, errors, and/or stream closure\n   * @param {CancellableStream} stream - the stream that we're doing the retry on\n   * @param {RetryOptions} retry - Configures the exceptions upon which the\n   *   function should retry, and the parameters to the exponential backoff retry\n   *   algorithm.\n   */\n  streamHandoffHelper(stream, retry) {\n    let enteredError = false;\n    const eventsToForward = ['metadata', 'response', 'status', 'data'];\n    eventsToForward.forEach(event => {\n      stream.on(event, this.emit.bind(this, event));\n    });\n    stream.on('error', error => {\n      enteredError = true;\n      this.streamHandoffErrorHandler(stream, retry, error);\n    });\n    stream.on('end', () => {\n      if (!enteredError) {\n        enteredError = true;\n        this.emit('end');\n        this.cancel();\n      }\n    });\n  }\n  /**\n   * Forward events from an API request stream to the user's stream.\n   * @param {Stream} stream - The API request stream.\n   * @param {RetryOptions} retry - Configures the exceptions upon which the\n   *   function should retry, and the parameters to the exponential backoff retry\n   *   algorithm.\n   */\n  forwardEvents(stream) {\n    const eventsToForward = ['metadata', 'response', 'status'];\n    eventsToForward.forEach(event => {\n      stream.on(event, this.emit.bind(this, event));\n    });\n    // gRPC is guaranteed emit the 'status' event but not 'metadata', and 'status' is the last event to emit.\n    // Emit the 'response' event if stream has no 'metadata' event.\n    // This avoids the stream swallowing the other events, such as 'end'.\n    stream.on('status', () => {\n      if (!this._responseHasSent) {\n        stream.emit('response', {\n          code: 200,\n          details: '',\n          message: 'OK'\n        });\n      }\n    });\n    // We also want to supply the status data as 'response' event to support\n    // the behavior of google-cloud-node expects.\n    // see:\n    // https://github.com/GoogleCloudPlatform/google-cloud-node/pull/1775#issuecomment-259141029\n    // https://github.com/GoogleCloudPlatform/google-cloud-node/blob/116436fa789d8b0f7fc5100b19b424e3ec63e6bf/packages/common/src/grpc-service.js#L355\n    stream.on('metadata', metadata => {\n      // Create a response object with succeeds.\n      // TODO: unify this logic with the decoration of gRPC response when it's\n      // added. see: https://github.com/googleapis/gax-nodejs/issues/65\n      stream.emit('response', {\n        code: 200,\n        details: '',\n        message: 'OK',\n        metadata\n      });\n      this._responseHasSent = true;\n    });\n    stream.on('error', error => {\n      googleError_1.GoogleError.parseGRPCStatusDetails(error);\n    });\n  }\n  defaultShouldRetry(error, retry) {\n    if (retry.retryCodes.length > 0 && retry.retryCodes.indexOf(error.code) < 0) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Forward events from an API request stream to the user's stream.\n   * @param {Stream} stream - The API request stream.\n   * @param {RetryOptions} retry - Configures the exceptions upon which the\n   *   function eshould retry, and the parameters to the exponential backoff retry\n   *   algorithm.\n   */\n  forwardEventsWithRetries(stream, retry) {\n    let retryStream = this.stream;\n    const eventsToForward = ['metadata', 'response', 'status'];\n    eventsToForward.forEach(event => {\n      stream.on(event, this.emit.bind(this, event));\n    });\n    // gRPC is guaranteed emit the 'status' event but not 'metadata', and 'status' is the last event to emit.\n    // Emit the 'response' event if stream has no 'metadata' event.\n    // This avoids the stream swallowing the other events, such as 'end'.\n    stream.on('status', () => {\n      if (!this._responseHasSent) {\n        stream.emit('response', {\n          code: 200,\n          details: '',\n          message: 'OK'\n        });\n      }\n    });\n    // We also want to supply the status data as 'response' event to support\n    // the behavior of google-cloud-node expects.\n    // see:\n    // https://github.com/GoogleCloudPlatform/google-cloud-node/pull/1775#issuecomment-259141029\n    // https://github.com/GoogleCloudPlatform/google-cloud-node/blob/116436fa789d8b0f7fc5100b19b424e3ec63e6bf/packages/common/src/grpc-service.js#L355\n    stream.on('metadata', metadata => {\n      // Create a response object with succeeds.\n      // TODO: unify this logic with the decoration of gRPC response when it's\n      // added. see: https://github.com/googleapis/gax-nodejs/issues/65\n      stream.emit('response', {\n        code: 200,\n        details: '',\n        message: 'OK',\n        metadata\n      });\n      this._responseHasSent = true;\n    });\n    stream.on('error', error => {\n      const timeout = retry.backoffSettings.totalTimeoutMillis;\n      const maxRetries = retry.backoffSettings.maxRetries;\n      if (maxRetries && maxRetries > 0 || timeout && timeout > 0) {\n        const e = googleError_1.GoogleError.parseGRPCStatusDetails(error);\n        let shouldRetry = this.defaultShouldRetry(e, retry);\n        if (retry.shouldRetryFn) {\n          shouldRetry = retry.shouldRetryFn(e);\n        }\n        if (shouldRetry) {\n          if (maxRetries && timeout) {\n            const newError = new googleError_1.GoogleError('Cannot set both totalTimeoutMillis and maxRetries ' + 'in backoffSettings.');\n            newError.code = status_1.Status.INVALID_ARGUMENT;\n            this.emit('error', newError);\n            this.destroy();\n            return; //end chunk\n          } else {\n            retryStream = this.retry(stream, retry);\n            this.stream = retryStream;\n            return retryStream;\n          }\n        } else {\n          const e = googleError_1.GoogleError.parseGRPCStatusDetails(error);\n          e.note = 'Exception occurred in retry method that was ' + 'not classified as transient';\n          this.destroy(e);\n          return; // end chunk\n        }\n      } else {\n        return googleError_1.GoogleError.parseGRPCStatusDetails(error);\n      }\n    });\n    return retryStream;\n  }\n  /**\n   * Resets the target stream as part of the retry process\n   * @param {CancellableStream} requestStream - the stream to end\n   */\n  resetStreams(requestStream) {\n    if (requestStream) {\n      requestStream.cancel && requestStream.cancel();\n      if (requestStream.destroy) {\n        requestStream.destroy();\n      } else if (requestStream.end) {\n        // TODO: not used in server streaming, but likely needed\n        // if we want to add BIDI or client side streaming\n        requestStream.end();\n      }\n    }\n  }\n  /**\n   * Specifies the target stream.\n   * @param {ApiCall} apiCall - the API function to be called.\n   * @param {Object} argument - the argument to be passed to the apiCall.\n   * @param {RetryOptions} retry - Configures the exceptions upon which the\n   *   function should retry, and the parameters to the exponential backoff retry\n   *   algorithm.\n   */\n  setStream(apiCall, argument, retryRequestOptions = {}, retry) {\n    this.apiCall = apiCall;\n    this.argument = argument;\n    if (this.type === StreamType.SERVER_STREAMING) {\n      if (this.rest) {\n        const stream = apiCall(argument, this._callback);\n        this.stream = stream;\n        this.setReadable(stream);\n      } else if (this.gaxServerStreamingRetries) {\n        const retryStream = (0, streamingRetryRequest_1.streamingRetryRequest)({\n          request: () => {\n            if (this._isCancelCalled) {\n              if (this.stream) {\n                this.stream.cancel();\n              }\n              return;\n            }\n            const stream = apiCall(argument, this._callback);\n            this.stream = stream;\n            this.stream = this.forwardEventsWithRetries(stream, retry);\n            return this.stream;\n          }\n        });\n        this.setReadable(retryStream);\n      } else {\n        const retryStream = retryRequest(null, {\n          objectMode: true,\n          request: () => {\n            if (this._isCancelCalled) {\n              if (this.stream) {\n                this.stream.cancel();\n              }\n              return;\n            }\n            const stream = apiCall(argument, this._callback);\n            this.stream = stream;\n            this.forwardEvents(stream);\n            return stream;\n          },\n          retries: retryRequestOptions.retries,\n          currentRetryAttempt: retryRequestOptions.currentRetryAttempt,\n          noResponseRetries: retryRequestOptions.noResponseRetries,\n          shouldRetryFn: retryRequestOptions.shouldRetryFn\n        });\n        this.setReadable(retryStream);\n      }\n      return;\n    }\n    const stream = apiCall(argument, this._callback);\n    this.stream = stream;\n    this.forwardEvents(stream);\n    if (this.type === StreamType.CLIENT_STREAMING) {\n      this.setWritable(stream);\n    }\n    if (this.type === StreamType.BIDI_STREAMING) {\n      this.setReadable(stream);\n      this.setWritable(stream);\n    }\n    if (this._isCancelCalled && this.stream) {\n      this.stream.cancel();\n    }\n  }\n}\nexports.StreamProxy = StreamProxy;","map":{"version":3,"names":["Object","defineProperty","exports","value","StreamProxy","StreamType","googleError_1","require","streamingRetryRequest_1","status_1","duplexify","retryRequest","constructor","type","callback","rest","gaxServerStreamingRetries","undefined","objectMode","readable","CLIENT_STREAMING","writable","SERVER_STREAMING","retries","_callback","_isCancelCalled","_responseHasSent","cancel","stream","retry","retryArgument","argument","getResumptionRequestFn","resumptionRetryArgument","resetStreams","newStream","apiCall","streamHandoffHelper","throwIfMaxRetriesOrTotalTimeoutExceeded","deadline","maxRetries","totalTimeoutMillis","now","Date","prevDeadline","getTime","error","GoogleError","code","Status","DEADLINE_EXCEEDED","emit","destroy","streamHandoffErrorHandler","retryStream","delayMult","backoffSettings","retryDelayMultiplier","maxDelay","maxRetryDelayMillis","timeoutMult","rpcTimeoutMultiplier","maxTimeout","maxRpcTimeoutMillis","delay","initialRetryDelayMillis","timeout","initialRpcTimeoutMillis","e","parseGRPCStatusDetails","shouldRetry","defaultShouldRetry","shouldRetryFn","toSleep","Math","random","setTimeout","min","timeoutCal","rpcTimeout","newDeadline","note","enteredError","eventsToForward","forEach","event","on","bind","forwardEvents","details","message","metadata","retryCodes","length","indexOf","forwardEventsWithRetries","newError","INVALID_ARGUMENT","requestStream","end","setStream","retryRequestOptions","setReadable","streamingRetryRequest","request","currentRetryAttempt","noResponseRetries","setWritable","BIDI_STREAMING"],"sources":["C:/Users/monir/node_modules/google-gax/build/src/streamingCalls/streaming.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.StreamProxy = exports.StreamType = void 0;\nconst googleError_1 = require(\"../googleError\");\nconst streamingRetryRequest_1 = require(\"../streamingRetryRequest\");\nconst status_1 = require(\"../status\");\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst duplexify = require('duplexify');\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst retryRequest = require('retry-request');\n/**\n * The type of gRPC streaming.\n * @enum {number}\n */\nvar StreamType;\n(function (StreamType) {\n    /** Client sends a single request, server streams responses. */\n    StreamType[StreamType[\"SERVER_STREAMING\"] = 1] = \"SERVER_STREAMING\";\n    /** Client streams requests, server returns a single response. */\n    StreamType[StreamType[\"CLIENT_STREAMING\"] = 2] = \"CLIENT_STREAMING\";\n    /** Both client and server stream objects. */\n    StreamType[StreamType[\"BIDI_STREAMING\"] = 3] = \"BIDI_STREAMING\";\n})(StreamType || (exports.StreamType = StreamType = {}));\nclass StreamProxy extends duplexify {\n    /**\n     * StreamProxy is a proxy to gRPC-streaming method.\n     *\n     * @private\n     * @constructor\n     * @param {StreamType} type - the type of gRPC stream.\n     * @param {ApiCallback} callback - the callback for further API call.\n     */\n    constructor(type, callback, rest, gaxServerStreamingRetries) {\n        super(undefined, undefined, {\n            objectMode: true,\n            readable: type !== StreamType.CLIENT_STREAMING,\n            writable: type !== StreamType.SERVER_STREAMING,\n        });\n        this.retries = 0;\n        this.type = type;\n        this._callback = callback;\n        this._isCancelCalled = false;\n        this._responseHasSent = false;\n        this.rest = rest;\n        this.gaxServerStreamingRetries = gaxServerStreamingRetries;\n    }\n    cancel() {\n        if (this.stream) {\n            this.stream.cancel();\n        }\n        else {\n            this._isCancelCalled = true;\n        }\n    }\n    retry(stream, retry) {\n        let retryArgument = this.argument;\n        if (typeof retry.getResumptionRequestFn === 'function') {\n            const resumptionRetryArgument = retry.getResumptionRequestFn(retryArgument);\n            if (resumptionRetryArgument !== undefined) {\n                retryArgument = retry.getResumptionRequestFn(retryArgument);\n            }\n        }\n        this.resetStreams(stream);\n        const newStream = this.apiCall(retryArgument, this._callback);\n        this.stream = newStream;\n        this.streamHandoffHelper(newStream, retry);\n        return newStream;\n    }\n    /**\n     * Helper function to handle total timeout + max retry check for server streaming retries\n     * @param {number} deadline - the current retry deadline\n     * @param {number} maxRetries - maximum total number of retries\n     * @param {number} totalTimeoutMillis - total timeout in milliseconds\n     */\n    throwIfMaxRetriesOrTotalTimeoutExceeded(deadline, maxRetries, totalTimeoutMillis) {\n        const now = new Date();\n        if (this.prevDeadline !== undefined &&\n            deadline &&\n            now.getTime() >= this.prevDeadline) {\n            const error = new googleError_1.GoogleError(`Total timeout of API exceeded ${totalTimeoutMillis} milliseconds before any response was received.`);\n            error.code = status_1.Status.DEADLINE_EXCEEDED;\n            this.emit('error', error);\n            this.destroy();\n            // Without throwing error you get unhandled error since we are returning a new stream\n            // There might be a better way to do this\n            throw error;\n        }\n        if (this.retries && this.retries >= maxRetries) {\n            const error = new googleError_1.GoogleError('Exceeded maximum number of retries before any ' +\n                'response was received');\n            error.code = status_1.Status.DEADLINE_EXCEEDED;\n            this.emit('error', error);\n            this.destroy();\n            throw error;\n        }\n    }\n    /**\n     * Error handler for server streaming retries\n     * @param {CancellableStream} stream - the stream being retried\n     * @param {RetryOptions} retry - Configures the exceptions upon which the\n     *   function should retry, and the parameters to the exponential backoff retry\n     *   algorithm.\n     * @param {Error} error - error to handle\n     */\n    streamHandoffErrorHandler(stream, retry, error) {\n        let retryStream = this.stream;\n        const delayMult = retry.backoffSettings.retryDelayMultiplier;\n        const maxDelay = retry.backoffSettings.maxRetryDelayMillis;\n        const timeoutMult = retry.backoffSettings.rpcTimeoutMultiplier;\n        const maxTimeout = retry.backoffSettings.maxRpcTimeoutMillis;\n        let delay = retry.backoffSettings.initialRetryDelayMillis;\n        let timeout = retry.backoffSettings.initialRpcTimeoutMillis;\n        let now = new Date();\n        let deadline = 0;\n        if (retry.backoffSettings.totalTimeoutMillis) {\n            deadline = now.getTime() + retry.backoffSettings.totalTimeoutMillis;\n        }\n        const maxRetries = retry.backoffSettings.maxRetries;\n        try {\n            this.throwIfMaxRetriesOrTotalTimeoutExceeded(deadline, maxRetries, retry.backoffSettings.totalTimeoutMillis);\n        }\n        catch (error) {\n            return;\n        }\n        this.retries++;\n        const e = googleError_1.GoogleError.parseGRPCStatusDetails(error);\n        let shouldRetry = this.defaultShouldRetry(e, retry);\n        if (retry.shouldRetryFn) {\n            shouldRetry = retry.shouldRetryFn(e);\n        }\n        if (shouldRetry) {\n            const toSleep = Math.random() * delay;\n            setTimeout(() => {\n                now = new Date();\n                delay = Math.min(delay * delayMult, maxDelay);\n                const timeoutCal = timeout && timeoutMult ? timeout * timeoutMult : 0;\n                const rpcTimeout = maxTimeout ? maxTimeout : 0;\n                this.prevDeadline = deadline;\n                const newDeadline = deadline ? deadline - now.getTime() : 0;\n                timeout = Math.min(timeoutCal, rpcTimeout, newDeadline);\n            }, toSleep);\n        }\n        else {\n            e.note =\n                'Exception occurred in retry method that was ' +\n                    'not classified as transient';\n            // for some reason this error must be emitted here\n            // instead of the destroy, otherwise the error event\n            // is swallowed\n            this.emit('error', e);\n            this.destroy();\n            return;\n        }\n        retryStream = this.retry(stream, retry);\n        this.stream = retryStream;\n        return;\n    }\n    /**\n     * Used during server streaming retries to handle\n     * event forwarding, errors, and/or stream closure\n     * @param {CancellableStream} stream - the stream that we're doing the retry on\n     * @param {RetryOptions} retry - Configures the exceptions upon which the\n     *   function should retry, and the parameters to the exponential backoff retry\n     *   algorithm.\n     */\n    streamHandoffHelper(stream, retry) {\n        let enteredError = false;\n        const eventsToForward = ['metadata', 'response', 'status', 'data'];\n        eventsToForward.forEach(event => {\n            stream.on(event, this.emit.bind(this, event));\n        });\n        stream.on('error', error => {\n            enteredError = true;\n            this.streamHandoffErrorHandler(stream, retry, error);\n        });\n        stream.on('end', () => {\n            if (!enteredError) {\n                enteredError = true;\n                this.emit('end');\n                this.cancel();\n            }\n        });\n    }\n    /**\n     * Forward events from an API request stream to the user's stream.\n     * @param {Stream} stream - The API request stream.\n     * @param {RetryOptions} retry - Configures the exceptions upon which the\n     *   function should retry, and the parameters to the exponential backoff retry\n     *   algorithm.\n     */\n    forwardEvents(stream) {\n        const eventsToForward = ['metadata', 'response', 'status'];\n        eventsToForward.forEach(event => {\n            stream.on(event, this.emit.bind(this, event));\n        });\n        // gRPC is guaranteed emit the 'status' event but not 'metadata', and 'status' is the last event to emit.\n        // Emit the 'response' event if stream has no 'metadata' event.\n        // This avoids the stream swallowing the other events, such as 'end'.\n        stream.on('status', () => {\n            if (!this._responseHasSent) {\n                stream.emit('response', {\n                    code: 200,\n                    details: '',\n                    message: 'OK',\n                });\n            }\n        });\n        // We also want to supply the status data as 'response' event to support\n        // the behavior of google-cloud-node expects.\n        // see:\n        // https://github.com/GoogleCloudPlatform/google-cloud-node/pull/1775#issuecomment-259141029\n        // https://github.com/GoogleCloudPlatform/google-cloud-node/blob/116436fa789d8b0f7fc5100b19b424e3ec63e6bf/packages/common/src/grpc-service.js#L355\n        stream.on('metadata', metadata => {\n            // Create a response object with succeeds.\n            // TODO: unify this logic with the decoration of gRPC response when it's\n            // added. see: https://github.com/googleapis/gax-nodejs/issues/65\n            stream.emit('response', {\n                code: 200,\n                details: '',\n                message: 'OK',\n                metadata,\n            });\n            this._responseHasSent = true;\n        });\n        stream.on('error', error => {\n            googleError_1.GoogleError.parseGRPCStatusDetails(error);\n        });\n    }\n    defaultShouldRetry(error, retry) {\n        if (retry.retryCodes.length > 0 &&\n            retry.retryCodes.indexOf(error.code) < 0) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Forward events from an API request stream to the user's stream.\n     * @param {Stream} stream - The API request stream.\n     * @param {RetryOptions} retry - Configures the exceptions upon which the\n     *   function eshould retry, and the parameters to the exponential backoff retry\n     *   algorithm.\n     */\n    forwardEventsWithRetries(stream, retry) {\n        let retryStream = this.stream;\n        const eventsToForward = ['metadata', 'response', 'status'];\n        eventsToForward.forEach(event => {\n            stream.on(event, this.emit.bind(this, event));\n        });\n        // gRPC is guaranteed emit the 'status' event but not 'metadata', and 'status' is the last event to emit.\n        // Emit the 'response' event if stream has no 'metadata' event.\n        // This avoids the stream swallowing the other events, such as 'end'.\n        stream.on('status', () => {\n            if (!this._responseHasSent) {\n                stream.emit('response', {\n                    code: 200,\n                    details: '',\n                    message: 'OK',\n                });\n            }\n        });\n        // We also want to supply the status data as 'response' event to support\n        // the behavior of google-cloud-node expects.\n        // see:\n        // https://github.com/GoogleCloudPlatform/google-cloud-node/pull/1775#issuecomment-259141029\n        // https://github.com/GoogleCloudPlatform/google-cloud-node/blob/116436fa789d8b0f7fc5100b19b424e3ec63e6bf/packages/common/src/grpc-service.js#L355\n        stream.on('metadata', metadata => {\n            // Create a response object with succeeds.\n            // TODO: unify this logic with the decoration of gRPC response when it's\n            // added. see: https://github.com/googleapis/gax-nodejs/issues/65\n            stream.emit('response', {\n                code: 200,\n                details: '',\n                message: 'OK',\n                metadata,\n            });\n            this._responseHasSent = true;\n        });\n        stream.on('error', error => {\n            const timeout = retry.backoffSettings.totalTimeoutMillis;\n            const maxRetries = retry.backoffSettings.maxRetries;\n            if ((maxRetries && maxRetries > 0) || (timeout && timeout > 0)) {\n                const e = googleError_1.GoogleError.parseGRPCStatusDetails(error);\n                let shouldRetry = this.defaultShouldRetry(e, retry);\n                if (retry.shouldRetryFn) {\n                    shouldRetry = retry.shouldRetryFn(e);\n                }\n                if (shouldRetry) {\n                    if (maxRetries && timeout) {\n                        const newError = new googleError_1.GoogleError('Cannot set both totalTimeoutMillis and maxRetries ' +\n                            'in backoffSettings.');\n                        newError.code = status_1.Status.INVALID_ARGUMENT;\n                        this.emit('error', newError);\n                        this.destroy();\n                        return; //end chunk\n                    }\n                    else {\n                        retryStream = this.retry(stream, retry);\n                        this.stream = retryStream;\n                        return retryStream;\n                    }\n                }\n                else {\n                    const e = googleError_1.GoogleError.parseGRPCStatusDetails(error);\n                    e.note =\n                        'Exception occurred in retry method that was ' +\n                            'not classified as transient';\n                    this.destroy(e);\n                    return; // end chunk\n                }\n            }\n            else {\n                return googleError_1.GoogleError.parseGRPCStatusDetails(error);\n            }\n        });\n        return retryStream;\n    }\n    /**\n     * Resets the target stream as part of the retry process\n     * @param {CancellableStream} requestStream - the stream to end\n     */\n    resetStreams(requestStream) {\n        if (requestStream) {\n            requestStream.cancel && requestStream.cancel();\n            if (requestStream.destroy) {\n                requestStream.destroy();\n            }\n            else if (requestStream.end) {\n                // TODO: not used in server streaming, but likely needed\n                // if we want to add BIDI or client side streaming\n                requestStream.end();\n            }\n        }\n    }\n    /**\n     * Specifies the target stream.\n     * @param {ApiCall} apiCall - the API function to be called.\n     * @param {Object} argument - the argument to be passed to the apiCall.\n     * @param {RetryOptions} retry - Configures the exceptions upon which the\n     *   function should retry, and the parameters to the exponential backoff retry\n     *   algorithm.\n     */\n    setStream(apiCall, argument, retryRequestOptions = {}, retry) {\n        this.apiCall = apiCall;\n        this.argument = argument;\n        if (this.type === StreamType.SERVER_STREAMING) {\n            if (this.rest) {\n                const stream = apiCall(argument, this._callback);\n                this.stream = stream;\n                this.setReadable(stream);\n            }\n            else if (this.gaxServerStreamingRetries) {\n                const retryStream = (0, streamingRetryRequest_1.streamingRetryRequest)({\n                    request: () => {\n                        if (this._isCancelCalled) {\n                            if (this.stream) {\n                                this.stream.cancel();\n                            }\n                            return;\n                        }\n                        const stream = apiCall(argument, this._callback);\n                        this.stream = stream;\n                        this.stream = this.forwardEventsWithRetries(stream, retry);\n                        return this.stream;\n                    },\n                });\n                this.setReadable(retryStream);\n            }\n            else {\n                const retryStream = retryRequest(null, {\n                    objectMode: true,\n                    request: () => {\n                        if (this._isCancelCalled) {\n                            if (this.stream) {\n                                this.stream.cancel();\n                            }\n                            return;\n                        }\n                        const stream = apiCall(argument, this._callback);\n                        this.stream = stream;\n                        this.forwardEvents(stream);\n                        return stream;\n                    },\n                    retries: retryRequestOptions.retries,\n                    currentRetryAttempt: retryRequestOptions.currentRetryAttempt,\n                    noResponseRetries: retryRequestOptions.noResponseRetries,\n                    shouldRetryFn: retryRequestOptions.shouldRetryFn,\n                });\n                this.setReadable(retryStream);\n            }\n            return;\n        }\n        const stream = apiCall(argument, this._callback);\n        this.stream = stream;\n        this.forwardEvents(stream);\n        if (this.type === StreamType.CLIENT_STREAMING) {\n            this.setWritable(stream);\n        }\n        if (this.type === StreamType.BIDI_STREAMING) {\n            this.setReadable(stream);\n            this.setWritable(stream);\n        }\n        if (this._isCancelCalled && this.stream) {\n            this.stream.cancel();\n        }\n    }\n}\nexports.StreamProxy = StreamProxy;\n//# sourceMappingURL=streaming.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}