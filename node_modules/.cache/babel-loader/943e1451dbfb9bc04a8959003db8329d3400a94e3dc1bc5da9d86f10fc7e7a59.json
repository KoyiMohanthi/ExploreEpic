{"ast":null,"code":"var crypto = require('crypto');\nvar saltChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\nvar saltCharsCount = saltChars.length;\nfunction generateSalt(len) {\n  if (typeof len != 'number' || len <= 0 || len !== parseInt(len, 10)) throw new Error('Invalid salt length');\n  if (crypto.randomBytes) {\n    return crypto.randomBytes(Math.ceil(len / 2)).toString('hex').substring(0, len);\n  } else {\n    for (var i = 0, salt = ''; i < len; i++) {\n      salt += saltChars.charAt(Math.floor(Math.random() * saltCharsCount));\n    }\n    return salt;\n  }\n}\nfunction generateHash(algorithm, salt, password, iterations) {\n  iterations = iterations || 1;\n  try {\n    var hash = password;\n    for (var i = 0; i < iterations; ++i) {\n      hash = crypto.createHmac(algorithm, salt).update(hash).digest('hex');\n    }\n    return algorithm + '$' + salt + '$' + iterations + '$' + hash;\n  } catch (e) {\n    throw new Error('Invalid message digest algorithm');\n  }\n}\nfunction makeBackwardCompatible(hashedPassword) {\n  var parts = hashedPassword.split('$');\n  if (parts.length === 3) {\n    parts.splice(2, 0, 1);\n    hashedPassword = parts.join(\"$\");\n  }\n  return hashedPassword;\n}\nmodule.exports.generate = function (password, options) {\n  if (typeof password != 'string') throw new Error('Invalid password');\n  options || (options = {});\n  options.algorithm || (options.algorithm = 'sha1');\n  options.saltLength || options.saltLength == 0 || (options.saltLength = 8);\n  options.iterations || (options.iterations = 1);\n  var salt = generateSalt(options.saltLength);\n  return generateHash(options.algorithm, salt, password, options.iterations);\n};\nmodule.exports.verify = function (password, hashedPassword) {\n  if (!password || !hashedPassword) return false;\n  hashedPassword = makeBackwardCompatible(hashedPassword);\n  var parts = hashedPassword.split('$');\n  if (parts.length != 4) return false;\n  try {\n    return generateHash(parts[0], parts[1], password, parts[2]) == hashedPassword;\n  } catch (e) {}\n  return false;\n};\nmodule.exports.isHashed = function (password) {\n  if (!password) return false;\n  return password.split('$').length == 4;\n};","map":{"version":3,"names":["crypto","require","saltChars","saltCharsCount","length","generateSalt","len","parseInt","Error","randomBytes","Math","ceil","toString","substring","i","salt","charAt","floor","random","generateHash","algorithm","password","iterations","hash","createHmac","update","digest","e","makeBackwardCompatible","hashedPassword","parts","split","splice","join","module","exports","generate","options","saltLength","verify","isHashed"],"sources":["C:/Users/monir/node_modules/password-hash/lib/password-hash.js"],"sourcesContent":["var crypto = require('crypto');\n\nvar saltChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\nvar saltCharsCount = saltChars.length;\n\nfunction generateSalt(len) {\n  if (typeof len != 'number' || len <= 0 || len !== parseInt(len, 10)) throw new Error('Invalid salt length');\n  if (crypto.randomBytes) {\n    return crypto.randomBytes(Math.ceil(len / 2)).toString('hex').substring(0, len);\n  } else {\n    for (var i = 0, salt = ''; i < len; i++) {\n      salt += saltChars.charAt(Math.floor(Math.random() * saltCharsCount));\n    }\n    return salt;\n  }\n}\n\nfunction generateHash(algorithm, salt, password, iterations) {\n  iterations = iterations || 1;\n  try {\n    var hash = password;\n    for(var i=0; i<iterations; ++i) {\n      hash = crypto.createHmac(algorithm, salt).update(hash).digest('hex');\n    }\n    \n    return algorithm + '$' + salt + '$' + iterations + '$' + hash;\n  } catch (e) {\n    throw new Error('Invalid message digest algorithm');\n  }\n}\n\nfunction makeBackwardCompatible(hashedPassword) {\n  var parts = hashedPassword.split('$');\n  if(parts.length === 3) {\n    parts.splice(2,0,1);\n    hashedPassword = parts.join(\"$\");\n  }\n  \n  return hashedPassword;\n}\n\nmodule.exports.generate = function(password, options) {\n  if (typeof password != 'string') throw new Error('Invalid password');\n  options || (options = {});\n  options.algorithm || (options.algorithm = 'sha1');\n  options.saltLength || options.saltLength == 0 || (options.saltLength = 8);\n  options.iterations || (options.iterations = 1);\n  var salt = generateSalt(options.saltLength);\n  return generateHash(options.algorithm, salt, password, options.iterations);\n};\n\nmodule.exports.verify = function(password, hashedPassword) {\n  if (!password || !hashedPassword) return false;\n  hashedPassword = makeBackwardCompatible(hashedPassword);\n  var parts = hashedPassword.split('$');\n  if (parts.length != 4) return false;\n  try {\n    return generateHash(parts[0], parts[1], password, parts[2]) == hashedPassword;\n  } catch (e) {}\n  return false;\n};\n\nmodule.exports.isHashed = function(password) {\n  if (!password) return false;\n  return password.split('$').length == 4;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}